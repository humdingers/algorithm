package com.unisound.dp;

//338. 比特位计数
/*
 * 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

    示例 1:
    
    输入: 2
    输出: [0,1,1]
    示例 2:
    
    输入: 5
    输出: [0,1,1,2,1,2]

 */
/*
 * 假设有一个整数：
x=(1001011101) 2
​ =(605) 10
​   
我们已经计算了从 0到 x−1 的全部结果。

我们知道，x 与 我们计算过的一个数只有一位之差:

x′=(1011101) 2
​  =(93) 10
​   
它们只在最高有效位上不同。

让我们以二进制形式检查 [0, 3][0,3] 的范围：
(0)=(0) 2
(1)=(1) 2
(2)=(10) 2
(3)=(11) 2
​
可以看出， 2 和 3 的二进制形式可以通过给 0 和 1 的二进制形式在前面加上 1 来得到。因此，它们的 pop count 只相差 1。

类似的，我们可以使用 [0, 3][0,3] 作为蓝本来得到 [4,7]。

总之，对于pop count P(x)，我们有以下的状态转移函数：

P(x + b) = P(x) + 1, b = 2^m > x

有了状态转移函数，我们可以利用动态规划从 0 开始生成所有结果
 */
public class CountBits
{
    public int[] countBits(int num)
    {
        int[] dp = new int[num + 1];
        int i = 0;
        int b = 1;
        // [0, b) is calculated
        while (b <= num) {
            // i 不能等于b.否则后面+b形成不了规律
            // 相差在高位1
            // generate [b, 2b) or [b, num) from [0, b)
            while (i < b && i + b <= num) {
                dp[i + b] = dp[i] + 1;
                i++;
            }

            i = 0;
            b <<= 1; // b = 2b
        }

        return dp;
    }

}
